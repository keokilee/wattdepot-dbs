package org.wattdepot.resource.property.jaxb;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotSame;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import org.junit.Test;

/**
 * Ensures that the equals() and hashCode() methods that have been manually added to the JAXB
 * autogenerated code are working. This is important, because if the schema files are changed and
 * new Java code is generated via XJC, then the manually added methods will be silently blown away.
 * These tests act as a backstop to ensure that if that happens, tests will fail.
 * 
 * If we eventually move to autogenerated equals() and hashCode() via XJC plugins, then these tests
 * will confirm that the plugins are working properly.
 * 
 * @author Robert Brewer
 */
public class TestPropertyJaxb {

  private final String key1 = "some-key", value1 = "some-value", key2 = "foo-key",
      value2 = "foo-value";

  private Property prop1, prop2, prop3, prop4;

  public TestPropertyJaxb() {

  }

  /**
   * Tests equals and hashCode for the Property type.
   */
  @Test
  public void testProperty() {
    this.prop1 = new Property(this.key1, this.value1);
    this.prop2 = new Property(this.key1, this.value1);

    assertNotSame("Two newly created Property are the same object", prop1, prop2);
    assertEquals("Two Property with identical keys and values are not equal", prop1, prop2);
    assertEquals("Two Property with identical keys and values have different hashCodes", prop1
        .hashCode(), prop2.hashCode());
    prop2.setValue("foo");
    assertFalse("Two different Property are equal.", prop1.equals(prop2));
    assertFalse("Two different Property have same hashcode.", prop1.hashCode() == prop2.hashCode());
  }

  /**
   * Tests the toString() method of Property.
   */
  @Test
  public void testPropertyToString() {
    this.prop1 = new Property(this.key1, this.value1);
    assertEquals("Property toString did not return expected result", "Property [key=" + this.key1
        + ", value=" + this.value1 + "]", prop1.toString());
  }

  /**
   * Tests the various specialized getProperty methods.
   */
  @Test
  public void testGetProperties() {
    this.prop1 = new Property(this.key1, "3.14159");
    this.prop2 = new Property(this.key2, "123412341234");
    Properties props1 = new Properties(), props2 = new Properties();

    props1.getProperty().add(prop1);
    props1.getProperty().add(prop2);

    assertEquals("getPropertyAsDouble didn't return correct value", 3.14159, props1
        .getPropertyAsDouble(this.key1), 0.00001);
    assertEquals("getPropertyAsDouble didn't 0 when it should", 0, props1
        .getPropertyAsDouble("nonexistent-key"), 0.00001);
    assertEquals("getPropertyAsDouble didn't 0 when it should", 0, props2
        .getPropertyAsDouble(this.key1), 0.00001);
    assertEquals("getPropertyAsLong didn't return correct value", 123412341234L, props1
        .getPropertyAsLong(this.key2));
    assertEquals("getPropertyAsLong didn't return 0 when it should", 0, props1
        .getPropertyAsLong("nonexistent-key"));
    assertEquals("getPropertyAsLong didn't 0 when it should", 0, props2
        .getPropertyAsLong(this.key1));
    assertNull("getProperty returned non-null for empty Properties", props2.getProperty(this.key1));
    assertEquals("getProperty didn't return correct value", "3.14159", props1
        .getProperty(this.key1));
    assertNull("getProperty didn't return correct value", props1.getProperty("nonexistent-key"));
    assertFalse("containsProperty returned non-null for empty Properties", props2
        .containsProperty(this.prop1));
    assertTrue("containsProperty returned false for expected Property", props1
        .containsProperty(this.prop1));
    assertFalse("containsProperty returned true for non-existent Property", props1
        .containsProperty(new Property("nonexistent-key", "baz")));
    assertFalse("isPropertyTrue returned true for non-existent Property", props1
        .isPropertyTrue("nonexistent-key"));
    props1.getProperty().add(new Property("qux", "tRuE"));
    assertTrue("isPropertyTrue returned false for Property set to true", props1
        .isPropertyTrue("qux"));
  }

  /**
   * Tests equals and hashCode for the Properties type.
   */
  @Test
  public void testProperties() {

    // Make two pairs of Property objects that have same keys &values
    this.prop1 = new Property(this.key1, this.value1);
    this.prop2 = new Property(this.key2, this.value2);
    this.prop3 = new Property(this.key1, this.value1);
    this.prop4 = new Property(this.key2, this.value2);
    Properties props1 = new Properties(), props2 = new Properties();

    props1.getProperty().add(prop1);
    props1.getProperty().add(prop2);
    props2.getProperty().add(prop3);
    props2.getProperty().add(prop4);

    assertNotSame("Two newly created Properties are the same object", props1, props2);
    assertEquals("Two Properties with lists of identical Property objects are not equal", props1,
        props2);
    assertEquals("Two Properties with identical lists have different hashCodes", props1.hashCode(),
        props2.hashCode());
    this.prop4.setValue("baz");
    assertFalse("Two different Properties are equal.", props1.equals(props2));
    assertFalse("Two different Properties have same hashcode.", props1.hashCode() == props2
        .hashCode());
  }
}
