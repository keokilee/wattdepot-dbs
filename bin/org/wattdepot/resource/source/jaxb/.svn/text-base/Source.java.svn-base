//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vhudson-jaxb-ri-2.1-833 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2009.08.31 at 03:06:32 PM HST 
//

package org.wattdepot.resource.source.jaxb;

import java.io.Serializable;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlSchemaType;
import javax.xml.bind.annotation.XmlType;
import org.wattdepot.resource.property.jaxb.Properties;
import org.wattdepot.resource.property.jaxb.Property;
import org.wattdepot.server.Server;

/**
 * <p>
 * Java class for anonymous complex type.
 * 
 * <p>
 * The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType&gt;
 *   &lt;complexContent&gt;
 *     &lt;restriction base=&quot;{http://www.w3.org/2001/XMLSchema}anyType&quot;&gt;
 *       &lt;sequence&gt;
 *         &lt;element ref=&quot;{}Name&quot;/&gt;
 *         &lt;element ref=&quot;{}Owner&quot;/&gt;
 *         &lt;element ref=&quot;{}Public&quot;/&gt;
 *         &lt;element ref=&quot;{}Virtual&quot;/&gt;
 *         &lt;element ref=&quot;{}Coordinates&quot;/&gt;
 *         &lt;element ref=&quot;{}Location&quot;/&gt;
 *         &lt;element ref=&quot;{}Description&quot;/&gt;
 *         &lt;element ref=&quot;{}SubSources&quot; minOccurs=&quot;0&quot;/&gt;
 *         &lt;element ref=&quot;{}Properties&quot; minOccurs=&quot;0&quot;/&gt;
 *       &lt;/sequence&gt;
 *     &lt;/restriction&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "", propOrder = { "name", "owner", "_public", "virtual", "coordinates", "location",
    "description", "subSources", "properties" })
@XmlRootElement(name = "Source")
public class Source implements Serializable, Comparable<Source> {

  private final static long serialVersionUID = 12343L;
  @XmlElement(name = "Name", required = true)
  protected String name;
  @XmlElement(name = "Owner", required = true)
  @XmlSchemaType(name = "anyURI")
  protected String owner;
  @XmlElement(name = "Public")
  protected boolean _public;
  @XmlElement(name = "Virtual")
  protected boolean virtual;
  @XmlElement(name = "Coordinates", required = true)
  protected String coordinates;
  @XmlElement(name = "Location", required = true)
  protected String location;
  @XmlElement(name = "Description", required = true)
  protected String description;
  @XmlElement(name = "SubSources")
  protected SubSources subSources;
  @XmlElement(name = "Properties")
  protected Properties properties;

  /** Property name for carbon intensity. */
  public static final String CARBON_INTENSITY = "carbonIntensity";
  /** Property key for fuel type. */
  public static final String FUEL_TYPE = "fuelType";
  /** Property key for update interval. */
  public static final String UPDATE_INTERVAL = "updateInterval";
  /** Property key for update interval. */
  public static final String ENERGY_DIRECTION = "energyDirection";
  /** Property key for update interval. */
  public static final String SUPPORTS_ENERGY_COUNTERS = "supportsEnergyCounters";

  /**
   * Default no-argument constructor, apparently needed by JAXB. Don't use this, use the one with
   * all the parameters.
   */
  public Source() {
    // Apparently needed by JAXB
  }

  /**
   * Returns a new Source object with the provided parameters. Needs to be kept up to date with any
   * changes to the schema, which is bogus.
   * 
   * @param name The name for the Source.
   * @param owner The owner URI for the Source.
   * @param publicp Whether the Source is public.
   * @param virtualp Whether the Source is virtual.
   * @param coordinates The coordinates for the Source.
   * @param location The location for the Source.
   * @param description The description of the Source.
   * @param props The properties for the Source.
   * @param subSources The subsources for the Source.
   */
  public Source(String name, String owner, boolean publicp, boolean virtualp, String coordinates,
      String location, String description, Properties props, SubSources subSources) {
    this.name = name;
    this.owner = owner;
    this._public = publicp;
    this.virtual = virtualp;
    this.coordinates = coordinates;
    this.location = location;
    this.description = description;
    this.properties = props;
    if (virtualp) {
      if (subSources == null) {
        throw new IllegalArgumentException("Attempted to create virtual source with no subsources");
      }
      else {
        this.subSources = subSources;
      }
    }
    else if (!virtualp && (subSources != null)) {
      throw new IllegalArgumentException("Attempted to create non-virtual source with subsources");
    }
  }

  /**
   * Returns a new Source object with the provided parameters. These are the bare minimum fields for
   * a Source.
   * 
   * @param name The name for the Source.
   * @param owner The owner URI for the Source.
   * @param publicp Whether the Source is public.
   */
  public Source(String name, String owner, boolean publicp) {
    this(name, owner, publicp, false, null, null, null, null, null);
  }

  /**
   * Gets the value of the name property.
   * 
   * @return possible object is {@link String }
   * 
   */
  public String getName() {
    return name;
  }

  /**
   * Sets the value of the name property.
   * 
   * @param value allowed object is {@link String }
   * 
   */
  public void setName(String value) {
    this.name = value;
  }

  public boolean isSetName() {
    return (this.name != null);
  }

  /**
   * Gets the value of the owner property.
   * 
   * @return possible object is {@link String }
   * 
   */
  public String getOwner() {
    return owner;
  }

  /**
   * Sets the value of the owner property.
   * 
   * @param value allowed object is {@link String }
   * 
   */
  public void setOwner(String value) {
    this.owner = value;
  }

  public boolean isSetOwner() {
    return (this.owner != null);
  }

  /**
   * Gets the value of the public property.
   * 
   */
  public boolean isPublic() {
    return _public;
  }

  /**
   * Sets the value of the public property.
   * 
   */
  public void setPublic(boolean value) {
    this._public = value;
  }

  public boolean isSetPublic() {
    return true;
  }

  /**
   * Gets the value of the virtual property.
   * 
   */
  public boolean isVirtual() {
    return virtual;
  }

  /**
   * Sets the value of the virtual property.
   * 
   */
  public void setVirtual(boolean value) {
    this.virtual = value;
  }

  public boolean isSetVirtual() {
    return true;
  }

  /**
   * Gets the value of the coordinates property.
   * 
   * @return possible object is {@link String }
   * 
   */
  public String getCoordinates() {
    return coordinates;
  }

  /**
   * Sets the value of the coordinates property.
   * 
   * @param value allowed object is {@link String }
   * 
   */
  public void setCoordinates(String value) {
    this.coordinates = value;
  }

  public boolean isSetCoordinates() {
    return (this.coordinates != null);
  }

  /**
   * Gets the value of the location property.
   * 
   * @return possible object is {@link String }
   * 
   */
  public String getLocation() {
    return location;
  }

  /**
   * Sets the value of the location property.
   * 
   * @param value allowed object is {@link String }
   * 
   */
  public void setLocation(String value) {
    this.location = value;
  }

  public boolean isSetLocation() {
    return (this.location != null);
  }

  /**
   * Gets the value of the description property.
   * 
   * @return possible object is {@link String }
   * 
   */
  public String getDescription() {
    return description;
  }

  /**
   * Sets the value of the description property.
   * 
   * @param value allowed object is {@link String }
   * 
   */
  public void setDescription(String value) {
    this.description = value;
  }

  public boolean isSetDescription() {
    return (this.description != null);
  }

  /**
   * Gets the value of the subSources property.
   * 
   * @return possible object is {@link SubSources }
   * 
   */
  public SubSources getSubSources() {
    return subSources;
  }

  /**
   * Sets the value of the subSources property.
   * 
   * @param value allowed object is {@link SubSources }
   * 
   */
  public void setSubSources(SubSources value) {
    this.subSources = value;
  }

  public boolean isSetSubSources() {
    return (this.subSources != null);
  }

  /**
   * Gets the value of the properties property.
   * 
   * @return possible object is {@link Properties }
   * 
   */
  public Properties getProperties() {
    return properties;
  }

  /**
   * Sets the value of the properties property.
   * 
   * @param value allowed object is {@link Properties }
   * 
   */
  public void setProperties(Properties value) {
    this.properties = value;
  }

  public boolean isSetProperties() {
    return (this.properties != null);
  }

  // Broke down and added these manually to the generated code. It would be better if they were
  // automatically generated via XJC plugins, but that required a bunch of dependencies that I
  // was unwilling to deal with right now. If the schema files change, this code will be blown
  // away, so there are unit tests that confirm that equals and hashCode work to guard against
  // that.

  /*
   * (non-Javadoc)
   * 
   * @see java.lang.Object#hashCode()
   */
  @Override
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + (_public ? 1231 : 1237);
    result = prime * result + ((coordinates == null) ? 0 : coordinates.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + ((location == null) ? 0 : location.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((owner == null) ? 0 : owner.hashCode());
    result = prime * result + ((properties == null) ? 0 : properties.hashCode());
    result = prime * result + ((subSources == null) ? 0 : subSources.hashCode());
    result = prime * result + (virtual ? 1231 : 1237);
    return result;
  }

  /*
   * (non-Javadoc)
   * 
   * @see java.lang.Object#equals(java.lang.Object)
   */
  @Override
  public boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }
    if (obj == null) {
      return false;
    }
    if (getClass() != obj.getClass()) {
      return false;
    }
    Source other = (Source) obj;
    if (_public != other._public) {
      return false;
    }
    if (coordinates == null) {
      if (other.coordinates != null) {
        return false;
      }
    }
    else if (!coordinates.equals(other.coordinates)) {
      return false;
    }
    if (description == null) {
      if (other.description != null) {
        return false;
      }
    }
    else if (!description.equals(other.description)) {
      return false;
    }
    if (location == null) {
      if (other.location != null) {
        return false;
      }
    }
    else if (!location.equals(other.location)) {
      return false;
    }
    if (name == null) {
      if (other.name != null) {
        return false;
      }
    }
    else if (!name.equals(other.name)) {
      return false;
    }
    if (owner == null) {
      if (other.owner != null) {
        return false;
      }
    }
    else if (!owner.equals(other.owner)) {
      return false;
    }
    if (properties == null) {
      if (other.properties != null) {
        return false;
      }
    }
    else if (!properties.equals(other.properties)) {
      return false;
    }
    if (subSources == null) {
      if (other.subSources != null) {
        return false;
      }
    }
    else if (!subSources.equals(other.subSources)) {
      return false;
    }
    if (virtual != other.virtual) {
      return false;
    }
    return true;
  }

  /*
   * (non-Javadoc)
   * 
   * @see java.lang.Comparable<T>#compareTo(java.lang.Comparable<T>)
   */
  @Override
  public int compareTo(Source o) {
    // if o is null, throw NullPointerException, per Comparable JavaDoc
    if (o == null) {
      throw new NullPointerException("Tried to compare Source with null");
    }
    if (o.equals(this)) {
      return 0;
    }
    // move on to the other fields for comparison
    int comparison;
    comparison = name.compareTo(o.getName());
    if (comparison != 0) {
      // names differ, so just return the comparison value
      return comparison;
    }
    // names are the same, so check owner field
    comparison = owner.compareTo(o.getOwner());
    if (comparison != 0) {
      // owners differ, so just return the comparison value
      return comparison;
    }
    // Check public flag, ordering true before false
    if (_public && !o.isPublic()) {
      return -1;
    }
    else if (!_public && o.isPublic()) {
      return 1;
    }
    // Check virtual flag, ordering true before false
    if (virtual && !o.isVirtual()) {
      return -1;
    }
    else if (!virtual && o.isVirtual()) {
      return 1;
    }
    comparison = coordinates.compareTo(o.getCoordinates());
    if (comparison != 0) {
      // coordinates differ, so just return the comparison value
      return comparison;
    }
    comparison = location.compareTo(o.getLocation());
    if (comparison != 0) {
      // locations differ, so just return the comparison value
      return comparison;
    }
    comparison = description.compareTo(o.getDescription());
    if (comparison != 0) {
      // description differ, so just return the comparison value
      return comparison;
    }
    // TODO Punting on SubSources and Properties, should really be compared for completeness

    // Should never get here, since testing every field individually should have same result as
    // equals() which we do first. Anyway, give up and say they are the same.
    return 0;
  }

  /*
   * (non-Javadoc)
   * 
   * @see java.lang.Object#toString()
   */
  @Override
  public String toString() {
    return "Source [name=" + name + ", public=" + _public + ", coordinates=(" + coordinates
        + "), description=" + description + ", location=" + location + ", owner=" + owner
        + ", properties=" + properties + ", subSources=" + subSources + ", virtual=" + virtual
        + "]";
  }

  /**
   * A convenience method to add a Property to the List of Property stored in the Properties field.
   * 
   * @param prop The Property to add.
   */
  public void addProperty(Property prop) {
    if (this.properties == null) {
      this.properties = new Properties();
    }
    this.properties.getProperty().add(prop);
  }

  /**
   * Returns the value of the Property with the given key as a double. If the key is not found, it
   * returns 0. Only the first property with the given key is returned. This is a convenience method
   * that calls the underlying Properties method.
   * 
   * @param key The key.
   * @return The key's value as a double.
   */
  public double getPropertyAsDouble(String key) {
    if (this.properties != null) {
      return this.properties.getPropertyAsDouble(key);
    }
    else {
      return 0;
    }
  }

  /**
   * Returns the value of the Property with the given key as a String. If the key is not found, it
   * returns null. Only the first property with the given key is returned. This is a convenience
   * method that calls the underlying Properties method.
   * 
   * @param key The key.
   * @return The key's value as a String.
   */
  public String getProperty(String key) {
    if (this.properties != null) {
      return this.properties.getProperty(key);
    }
    else {
      return null;
    }
  }

  /**
   * Returns whether the value of the Property with the given key is true. If the key is not found,
   * or the value is anything other than a variation of "true", returns false. Only the first
   * property with the given key is returned. This is a convenience method that calls the underlying
   * Properties method.
   * 
   * @param key The key.
   * @return The key's value as a boolean.
   */
  public boolean isPropertyTrue(String key) {
    if (this.properties != null) {
      return this.properties.isPropertyTrue(key);
    }
    else {
      return false;
    }
  }

  /**
   * Given the URI for a WattDepot server, returns the URI to this Source resource.
   * 
   * @param serverUri The URI of the server this sensor data belongs to.
   * @return The URI to the Source resource corresponding to this Source object.
   */
  public String toUri(String serverUri) {
    return serverUri + Server.SOURCES_URI + "/" + this.getName();
  }

  /**
   * Given the Server a Source object belongs to, returns the URI to that Source resource.
   * 
   * @param server The Server user belongs to.
   * @return The URI to the Source resource corresponding to the given Source.
   */
  public String toUri(Server server) {
    return toUri(server.getHostName());
  }

  /**
   * Takes the URI to a Source resource on an arbitrary WattDepot server, and turns it into a URI
   * for that source on the provided server. This is useful when reading a SensorData resource from
   * a file, where the stored URI might point to an source resource that is on a different server.
   * 
   * @param uri The URI that is to be updated.
   * @param server The current server instance.
   * @return A URI String for the given source on the given server.
   */
  public static String updateUri(String uri, Server server) {
    // Grab out the username at the end of the URI
    String sourceName = uri.substring(uri.lastIndexOf('/') + 1);
    return sourceToUri(sourceName, server);
  }

  /**
   * Given a Source name and the server URI it belongs to, returns the URI to that Source resource.
   * 
   * @param sourceName The Source object under consideration.
   * @param serverUri The server URI source belongs to.
   * @return The URI to the Source resource corresponding to the given Source name.
   */
  public static String sourceToUri(String sourceName, String serverUri) {
    return serverUri + Server.SOURCES_URI + "/" + sourceName;
  }

  /**
   * Given a Source name and the Server it belongs to, returns the URI to that Source resource.
   * 
   * @param sourceName The Source object under consideration.
   * @param server The Server source belongs to.
   * @return The URI to the Source resource corresponding to the given Source name.
   */
  public static String sourceToUri(String sourceName, Server server) {
    return server.getHostName() + Server.SOURCES_URI + "/" + sourceName;
  }
}
